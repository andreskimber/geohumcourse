# Veebirakendused, veebimajutus {#veebirakendused}

Tavalised arvutis hoitavad kaardid on **digitaalsed kaardid**, mille võib panna ka veebilehele, ent mille koostamine, säilitamine ja näitamine ei sõltu kuidagi veebitehnoloogiast. Digitaalsed kaardid on staatilised. **Veebikaardid** aga lihtsalt ei paikne veebis, vaid on veebist sõltuvad: nii nende koostamine kui ka vaatamine sõltub veebitehnoloogiast. Sageli on veebikaardid dünaamilised, interaktiivsed ning võivad kasutada ka mujalt veebist päritavaid andmeid.

Lisaks sellele, et veebikaartidel saab kuvada korraga mitut kihti, mingeid kihte sisse ja välja lülitada või kasutada andmete esitamiseks animatsiooni, saab nendele lisada ka erinevaid lisaelemente, näiteks sisse- ja väljasuumimine, vahemaade mõõtmine, legend, pealkirjad, otsing jpm. Samuti saab määrata, mis juhtub, kui kasutaja liigub hiirega mingi punkti peale, sellel klikib või mingil muul moel veebikaardiga suhtleb.  

Tänapäevase veebikaardi aluskaart koosneb **paanidest** (*tiles*), tüüpiliselt 256×256 piksli suurustest rasterpiltidest (aga juba ka vektoritest), mida laaditakse vastavalt kasutaja valikutele kaardipaanide serverist (näiteks OpenStreetMapi serverist). See tähendab, et kasutajale näidatakse ainult seda osa kaardist, mida tal on vaja näha, muutes kaardi laadimise oluliselt kiiremaks.  

```{r tiles, echo=F, fig.show='hold', fig.align='center', out.width= "70%", fig.cap= "Kaardipaanide laadimine (Allikas: [Axis Maps](https://www.axismaps.com/guide/what-is-a-web-map))"}
knitr::include_graphics(here::here("imgs", "19_tiles.gif"))
```

Aluskaart annab sinu veebikaardile geograafilise konteksti, ent ei ole iseenesest kaardi tegemise ega vaatamise põhjuseks. Aluskaardil saab omakorda kuvada muid vektor- või rasterandmeid.

Suur osa veebikaartidest (ja neid pakkuvatest APIdest) on vaikimisi **Web Mercatori** (EPSG:3857) projektsioonis, mille puhul peab arvestama sellega, et alade suurus on moonutatud. 

<iframe width="100%" height="480px" src="https://thetruesize.com/#?borders=1~!MTU2MDMyNDc.NDgyOTAxOQ*MzM0ODE1MTM(NDAxMDYxNQ~!CONTIGUOUS_US*MTAwMjQwNzU.MjUwMjM1MTc(MTc1)MA~!IN*NTI2NDA1MQ.Nzg2MzQyMQ)Mg~!CN*OTkyMTY5Nw.NzMxNDcwNQ(MjI1)MQ" frameborder="0" scrolling="yes"></iframe>

Kui tahta teha sageli, palju või korralikke veebikaarte ja kaardirakendusi, tasub vähemalt mingil algtasemel ära õppida keel, milles seda teha saab. 
Veebilehed kasutavad (vähemalt) [**HTML**](https://www.w3schools.com/html/default.asp)i, et veebilehte struktureerida, [**CSS**](https://www.w3schools.com/css/default.asp)i, et veebilehte kujundada, ning [**JavaScript**](https://www.w3schools.com/js/default.asp)i, et lisada veebilehele interaktiivsust.
<!-- javascript võib lehe sisu muuta, muuta selle väljanägemist mingis brauseris, saata serverile mingit informatsiooni või küsida serverilt uut informatsiooni-->


```{r htmlcssjs, echo=F, fig.show='hold', fig.align='center', out.width= "50%", fig.cap= "HTML, JavaScript ja CSS (Allikas: [dev.to](https://dev.to/fabcodingzest/how-to-get-started-with-web-development-front-end-part-1-5c6h))"}
knitr::include_graphics(here::here("imgs", "19_htmlcssjs.jpg"))
```

Ühe lihtsa veebilehe struktuur HTML-failis võib välja näha näiteks selline: 

```
<!DOCTYPE html>
<html>
  <head>
    <title>Minu lehe pealkiri</title>
    <link href="stiil.css" type="text/css" rel="stylesheet">
  </head>
  <body bgcolor="black" text="white">
    <h1>Minu esimene veebileht</h1>
    <p>Siin on mingi tekst.</p>
	<p>Siin on <a href="https://tartugeohum.github.io/" target="_blank">link</a>, kust leiab kõik selle kursuse materjalid</p>
    <p>Siin all on nupp, millele vajutades saab veel midagi teada.</p>
    <p id="pealkiri" style="display:none">See on minu esimene veebileht!</p>
    <button type="button" onclick="document.getElementById('pealkiri').style.display='block'">Vajuta siia!</button>
  </body>
</html>
```

Selle veebilehe juurde käiv CSS-fail omakorda selline:

```
h1{
  text-align: center;
  color: blue;
  font-size: 40px;
}
p{
  font-family: courier;
  font-size: 20px;
}
```

Kokku saab ühe väga lihtsa lehe, mis näeb välja selline:

```{r html, echo=F, fig.show='hold', fig.align='center', out.width= "100%", fig.cap= "Lihtne veebileht"}
knitr::include_graphics(here::here("imgs", "19_html.PNG"))
```

Interaktiivsete **veebikaartide** jaoks kasutatakse sageli näiteks JavaScripti teekide/pakettide [**Leaflet**](https://leafletjs.com/)i või [**OpenLayers**](https://openlayers.org/)i APIsid (*Application Programming Interface*), mis suhtlevad erinevate serveritega ning muudavad ja kuvavad kaarti vastavalt kasutaja valikutele. Mõlemad teegid on vabavaralised ja avatud lähtekoodiga, samas kui näiteks Google Mapsi API ja ArcGISi API on seotud konkreetse omandusliku (*proprietary*) tarkvaraga. 
<!-- Veebikaartide APId sisaldavad kaardiklasse ja kihte, ilma et peaks ise kirjutama tervet pikka koodi, millega mingit kaarti programmaatiliselt joonistada. APIde abil saab seega kirjutada programme kiiremini ja lihtsamalt -->

```{r leafletOL, echo=F, fig.show='hold', fig.align='center', out.width= "28%", fig.cap= "Leaflet ja OpenLayers"}
knitr::include_graphics(here::here("imgs", c("19_leaflet.png", "19_openlayers.png")))
```


Leafleti kasutatakse üldiselt rohkem, see on ökonoomsem, lihtsama APIga ning sobib hästi lihtsamate kaardirakenduste tegemiseks (*Leaflet does the 20% of things that are required 80% of the time*). Samas saab paljud funktsioonid kätte ainult erinevatest pluginatest ning kõiki võib-olla ei olegi veel olemas. Suure hulga funktsionaalsustega kaardirakenduste jaoks soovitatakse kasutada pigem OpenLayersit, mille API on keerulisem, ent selle võrra on see paindlikum ning pakub rohkem funktsioone. 

Ka Mapbox pakub oma JavaScripti teeki/paketti **[Mapbox GL JS](https://docs.mapbox.com/mapbox-gl-js/guides/)**, mis võimaldab koostada veebikaarte ja kaardirakendusi.  


## Kaardikihid QGISis

Eelmisel korral tegime kaardi, kus interpoleerisime **murdekorpuse sagedusandmete** põhjalt "ei ole" ja "pole"  rasterkihi, kus kihelkondade keskpunktide väärtuste järgi oli ennustatud ka vahepealseid väärtusi, kuigi sealt algselt andmeid ei olnud.

Seekord teeme võrdluseks kaardid **murdeatlase levikuandmete** põhjalt. Selleks teeme esmalt ettevalmistusi:  

1) laadime QGISi kihelkondade ja atlase andmete vektorkihid,  
2) filtreerime punktikihilt välja read, kus keelendeid ei ole, ja salvestame selle eraldi kihina faili,  
3) teeme uuele kihile uue tulba nimega *bin_value*, kus oleks väärtus `0` ridadel, kus tulbas *Keelend* on ka *p*-täht (*pole*), ning väärtus `1` ridadel, kus seal *p*-tähte ei ole (*ei ole*).   
4) värvime punktid vastavalt variandile "ei ole" või "pole".

### Heatmap

Teeme nüüd esmalt lihtsalt punktide jaotumise KDE *heatmap*'i, et näha, kust üldse andmeid rohkem on. 

- *Processing* -> *Toolbox* -> *Heatmap (Kernel Density Estimation)*  
- Määrame raadiuseks 30 km ja piksli suuruseks 500.  
- Lõikame rastri kihelkondade kihi järgi (*Raster* -> *Extraction* -> *Clip Raster by Mask Layer*).  
- Värvime rastri nii, et alad, kust on rohkem punkte, on tumedamad.  
- Nimetame lõigatud ja värvitud rastri nt nimega *KDE punktitihedus*.   


### Punktide Thin Plate Spline rasterkiht 

Järgmiseks teeme rasterkihi *Thin Plate Spline* meetodiga, et ennustada "ei ole" *vs.* "pole" väärtusi ka nendele aladele, kust atlases punkte ei ole.  

- *Processing* -> *Toolbox* -> *Thin Plate Spline*  
- Kasutame atlase punktikihi *bin_value* tulpa, kus on ainult väärtused 0 ja 1. Rasterkihil niisiis ennustame väärtusi 0 ja 1 vahepeale (tegelikult ka üle ja alla nende).  
- Määrame piksli suuruseks 500 ja *Regularisation* väärtuseks 0,1.  
- Lõikame rastri kihelkondade kihi järgi.   
- Värvime rastri nii, et alad, mis on *pole*-lembesemad, on tumedamad.  
- Nimetame lõigatud ja värvitud rastri nt nimega *TPS punktidega*.  


### Osakaalude Thin Plate Spline rasterkiht

Lõpetuseks teeme kolmanda rasterkihi, kus üldistame igale kihelkonnale mingi kindla "pole" osakaalu ja interpoleerime kihelkondade keskpunktide järgi. See sarnaneb paljuski sellele, mida tegime eelmiselgi korral.    

- Loeme kokku iga kihelkonna piiridesse jäävad punktid: *Processing* -> *Toolbox* -> *Count points in polygon*. Nimetame kihi nimega *kokku*.   
- Loeme kokku iga kihelkonna piiridesse jäävad *pole* punktid. Selleks valime punktikihil kõigepealt ainult punktid, millel tulbas *bin_value* on 0, ning seejärel kasutame taas tööriista *Count points in polygon* (NB! *Selected features only*).  
- Ühendame kokku ja pole andmed (*Join attributes by field value*) kihiks *pole* ning teeme ühendatud kihile uue tulba *poleprop*, kuhu arvutame *pole*-punktide osakaalu kõikide punktide arvust.  
- Leiame ühendatud andmekihi keskpunktid (*Vector* -> *Geometry tools* -> *Centroids*).  
- Loome keskpunktide kihist nüüd TPS meetodiga uue rasterkihi, kasutades samu parameetreid, mida eelmisegi rastri puhul.  
- Lõikame rastri kihelkondade kihi järgi, värvime rastri nii, et alad, mis on *pole*-lembesemad, on tumedamad, ja nimetame lõigatud ja värvitud rastri nimega *TPS osakaaludega*.  




## Veebikaartide eksportimine

Eemaldame loodud kihtidelt tunnused, mida me ei taha veebikaardil näidata,  valime kaardile aluskaardi (*QuickMapServices*) ja muudame projekti projektsiooni EPSG:3857ks.  

Tehtud kaartide hõlpsaks lisamiseks veebi saab installida nüüd **qgis2web** plugina. See genereerib QGISi projektist kas OpenLayersi, Leafleti või Mapboxi API abil veebikaardi tervikliku veebilehena koos kõikide vajalike kaustade ja failidega, ilma et peaksime tingimata ise JavaScriptis, CSSis ja HTMLis koodi kirjutama. 

Vali seejärel *Web* -> *qgis2web* -> *Create web map*.  


Katseta erinevate sätetega, võrdle OpenLayersi ja Leafleti failide suurusi, failistruktuure.
Veebikaardi saab (lokaalselt) eksportida, kasutades nuppu *Export*.  


## Veebikaartide majutamine

Valmis veebikaardi jagamiseks teistega võid saata kogu rakenduse kausta kellelegi lokaalselt vaatamiseks või selle kuskile serverisse avalikult üles panna. 


### Ülikooli võrguketas

Tartu Ülikooli tudengitel ja töötajatel on TÜ serveris \\\\pohl.ut.ee oma võrguketas (vaikimisi 1GB), kus on võimalik hoida ja varundada oma isiklikke faile. Samuti saab TÜ serverisse oma kodukataloogi salvestada ja üles panna loodud veebilehed (vaata juhendit [siit](https://www.ut.ee/et/4891)). Veebilehed tuleks salvestada kodukataloogi alamkausta **public_html** ning nendele saab ligi aadressilt **`https://kodu.ut.ee/~kasutajanimi/`**.  

Ülikooli võrguketastele ligipääsemiseks peab olema ülikooli sisevõrgus. Väljastpoolt ülikooli saab sisevõrku turvaliselt [ühenduse virtuaalse privaatvõrgu](https://wiki.ut.ee/pages/viewpage.action?pageId=17105590) (**VPN**) abil. 

Ülikooli sisevõrgus olles saab isikliku võrguketta kodu- või sülearvutile [külge haakida](https://wiki.ut.ee/pages/viewpage.action?pageId=17105488). NB! Kui küsitakse kasutajanime, siis see olgu kujul domenis\\kasutajanimi (mitte kasutajanimi@ut.ee)
 
(Kui see kohe ei tööta, siis proovi esmalt [seda](https://www.techcrumble.net/2018/03/you-cant-access-this-shared-folder-because-your-organizations-security-policies-block-unauthenticated-guest-access/).)

### GitHub

Veebikaarte saab tasuta majutada näiteks ka [**GitHubis**](https://github.com/) (vaata lühikest juhendit [siit](https://rogerdudler.github.io/git-guide/)). Selleks tuleks teha uus avalik repositoorium, kuhu paigutada *qgis2web*i väljundkausta sisu (sh kindlasti ka fail *index.html*). Vaata juhendit näiteks [siit](https://github.com/NieneB/Webmapping_for_beginners/wiki/Hosting-on-github). 

Tee endale GitHubi konto ning seal loo uus repositoorium, nt kas üldisema nimega *veebikaart* või spetsiifilisema nimega, nt *eiole_pole_kaart*.    

Kõige lihtsam on GitHubis toimetada [GitHub Desktopi](https://desktop.github.com/) rakenduse abil. 

- Laadi programm alla.
- Ava programm.  
- Vali *File* -> *Options* -> *Accounts* ning logi sisse GitHub.com kontole oma GitHubi kasutajanime ja parooliga (võib toimuda läbi brauseri).  
- Järgmiseks vali avalehel *Clone a repository from the Internet* ning filtreeri välja veebis loodud repositoorium (nt *MPilvik/veebikaart*). Vali see, vali oma arvutis koht, kus tahad seda kausta lokaalselt enda arvutis hoida, ning vajuta *Clone*. Nüüd tekib sinu arvutis vastavasse kausta uus tühi kaust.  
- Sikuta sellesse tühja kausta kogu qgis2web plugina eksporditud väljund.  
- Mine tagasi GitHub Desktopi rakendusse. Näed, et rakendus näitab sulle kaustas toimunud muudatusi (lisamisi, kustutamisi, muid muudatusi).  
- Selleks, et veebikaardi materjale nüüd GitHubi üles lükata, tuleb need n-ö *commit*'ida ning seejärel *push*'ida. All vasakus nurgas on kastike koos nupuga *Commit to main*. Lisa *Summary* väljale mingi kirjeldus, mis uuendusi üles laadid (nt *veebikaardi materjalid*) ning vajuta *Commit to main* nupule.  
- Lõpuks pead vajutama *Publish branch/Push origin* nupule, et kõik veebi üles laadida.  
- Lehel github.com peaksid nüüd sisse logides nägema, et qgis2webi väljundid (sh index.html) on kõik loodud veebikaardi kaustas.  
- Lõpuks tuleb veebileht ka rakendusena nähtavaks teha. Selleks saab kasutada **GitHub Pages** veebimajutuse teenust. Vali oma repositooriumis *Settings* -> *Pages* -> *Source* = *main* ja vajuta *Save*. Oota paar sekundit ning mine lehele https://sinukasutajanimi.github.io/sinurakendusenimi/


Kuskile serverisse riputatud veebilehte saab omakorda paigutada teise veebilehe sisse, nt HTML-i [**iframe**](https://www.w3schools.com/tags/tag_iframe.ASP)-märgendi abil (kaart ilmub siia pärast praktikumi lõppu). 

<!--<iframe src="https://mpilvik.github.io/veebikaart/index.html" width="100%" height="400" style="border:none;" title="Veebikaart GitHubist (mpilvik.github.io/veebikaart/)"></iframe>-->



Oma veebikaarte võib jagada ka otse QGISist, nt [QGIS Cloud](https://qgiscloud.com/)i või [Gisquick](http://gisquick.org/) pluginate abil. 


