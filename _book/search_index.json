[["r2.html", "Praktikum 21 Ruumiandmete analüüs R-iga 2 21.1 Staatilised kaardid 21.2 Shiny rakendus 21.3 Pakettide laadimine ja andmete töötlemine 21.4 Kasutajaliides 21.5 Server 21.6 Rakenduse kokkupanemine 21.7 Rakenduse jagamine", " Praktikum 21 Ruumiandmete analüüs R-iga 2 Eelmisel korral vaatasime, kuidas R-iga lihtsamaid kaarte teha. See hõlmas vajalike pakettide laadimist, need = c(&quot;tidyverse&quot;, &quot;sf&quot;, &quot;magrittr&quot;, &quot;ggspatial&quot;, &quot;ggthemes&quot;) invisible(lapply(need, library, character.only = T)) või library(&quot;sf&quot;) library(&quot;tidyverse&quot;) library(&quot;magrittr&quot;) library(&quot;ggspatial&quot;) library(&quot;ggthemes&quot;) andmete sisselugemist, maakonnad = st_read(&quot;./andmed/maakond_lihtsustatud.gpkg&quot;) andmete filtreerimist, saaremaa = maakonnad %&gt;% filter( MNIMI == &quot;Saare maakond&quot; ) või maakonnad %&gt;% filter(MNIMI == &quot;Saare maakond&quot;) -&gt; saaremaa või saaremaa &lt;- filter(maakonnad, MNIMI == &quot;Saare maakond&quot;) andmete visualiseerimist. ggplot(saaremaa) + geom_sf() Sel korral kasutame Eesti filmide andmestikku, teeme paar staatilist kaarti ning vaatame ka, kuidas teha R-is lihtsat rakendust, mis kuvaks andmestiku alamosast kaarti vastavalt kasutaja valikutele. Siin tuleb osata pisut R-i (või juhendeid lugeda), aga mitte näiteks JavaScripti ega HTMLi. 21.1 Staatilised kaardid Loeme alustuseks sisse terve efis.ee lehelt korjatud kohamärksõnadega tabeli failist efis_kohad.csv, kus on kõikide kohtadega seotud filmid, nende ilmumisaasta ning anr. Seejärel loeme sisse ka geokodeeritud alamosa suurest tabelist, mida kasutasime 19. praktikumis. Seal olid ainult need Eesti kohanimed, mida esines terves andmestikus kõikide aastate peale vähemalt 5 korda. Samuti loeme sisse maakondade kihi, mida saame kasutada aluskaardina. efis_suur &lt;- read.csv(&quot;andmed/efis_kohad.csv&quot;, sep = &quot;\\t&quot;, fileEncoding = &quot;UTF-8&quot;) efis_eesti &lt;- st_read(&quot;andmed/efis_eesti.gpkg&quot;) maakonnad &lt;- st_read(&quot;andmed/maakond_lihtsustatud.gpkg&quot;) Ühendame kaks andmestikku nii, et meil ei oleks kaardil võimalik näidata enam mitte ainult üldist infot selle kohta, kui palju mingites filmides teatud aastatel mingeid kohti esines, vaid saaksime kaardil kuvada andmebaasi alamosi ka nt anri järgi. Kasutame ühendamiseks mõlema andmestiku ühist tulpa koht. Kõigepealt aga tuleb andmestikus efis_suur viia kohanimed kujult A. Laikmaa tänav (Tallinn) kujule A. Laikmaa tänav, Tallinn, nagu need on geokodeeritud andmestikus. efis_suur$koht %&gt;% gsub(&quot;^(.*) \\\\((.*)\\\\)&quot;, &quot;\\\\1, \\\\2&quot;, .) %&gt;% trimws() -&gt; efis_suur$koht # Käsku võib lugeda nii, et salvesta tabeli &quot;efis_suur&quot; tulp &quot;koht&quot; üle nii, et # olemasolevas tulbas võta kirje algusest kuni sulu ees oleva tühikuni kõik, mis seal on # (. &lt;- &quot;ükskõik mis sümbol&quot;, * &lt;- &quot;ükskõik, kui mitu korda&quot;), # seejärel võta sulgude seest ükskõik, mis seal on, # ja kleebi need kaks kokku nii, et esimest ja teist osa eraldaks koma ja tühik. # Lõpuks kustuta kirjete eest ja tagant ka võimalikud ebavajalikud tühikud. Kuna tahame efis_eesti kihilt kasutada ainult kohtade nimesid ja koordinaate, salvestame selle osa andmestikust eraldi objekti. efis_eesti %&gt;% select(koht) %&gt;% unique() -&gt; efis_eesti_kohad Ühendame nüüd andmestikud funktsiooniga merge(). merge(efis_eesti_kohad, efis_suur, by = &quot;koht&quot;) -&gt; efis_koord Vaatame, mis juhtus. # Andmetabeli esimesed read head(efis_koord) Iga suure tabeli kirje, mis leidus ka geokodeeritud andmestikus, sai nüüd juurde ka koordinaadid. Need kirjed, mida geokodeeritud andmestikus ei olnud, jäid välja. # Millised erinevad anrikirjed tabelis on? Mis on kõige sagedamad? efis_koord$anr %&gt;% table() %&gt;% sort(decreasing = T) # Punktide kaart (ilma aluskaardita) ggplot(efis_koord) + geom_sf() Lisame nüüd punktidele alla maakondade aluskaardi ning näitame ainult neid andmestiku punkte, mis käivad selliste kohtade kohta, mida näidati 2021. aasta dokumentaal- ja mängufilmides. ggplot(data = maakonnad) + geom_sf() + # maakondade aluskaardi kiht geom_sf(data = efis_koord %&gt;% # efise andmestikust valime read, kus filter(aasta == 2021, # aasta on 2021 ja grepl(&quot;([dD]okumentaal)|([mM]ängufilm)&quot;, anr)) %&gt;% # anri tulp sisaldab sõna &quot;dokumentaal&quot;, &quot;Dokumentaal&quot;, &quot;mängufilm&quot; või &quot;Mängufilm&quot; group_by(koht, anr) %&gt;% # grupeerime andmed kohanime ja anri põhjal summarise(kokku = n()), # loeme gruppides andmepunktid kokku aes(size = kokku, color = anr), # määrame punktide suuruse esinemise arvu järgi ja punktide värv anri järgi alpha = 0.2) + # teeme punktid läbipaistvamaks scale_size_continuous(range = c(3,7)) + # ja suuremaks theme_bw() # lisame mustvalge teema See ei ole kõige mugavam viis neid andmeid vaadata. Võime proovida mingile kindlale alale sisse suumida. ggplot(data = maakonnad) + geom_sf() + geom_sf(data = efis_koord %&gt;% filter(aasta == 2021, grepl(&quot;([dD]okumentaal)|([mM]ängufilm)&quot;, anr)) %&gt;% group_by(koht, anr) %&gt;% summarise(kokku = n()), aes(size = kokku, color = anr), alpha = 0.2) + scale_size_continuous(range = c(3,7)) + theme_bw() + coord_sf(xlim = st_bbox(maakonnad %&gt;% filter(MNIMI == &quot;Tartu maakond&quot;))[c(1,3)], ylim = st_bbox(maakonnad %&gt;% filter(MNIMI == &quot;Tartu maakond&quot;))[c(2,4)]) Võime proovida punkte ka näiteks anride kaupa eraldi paneelidel kuvada. Kuna aga ühel filmil võib olla mitu kategooriat, tuleks meil filmid eraldi klassifitseerida: kui anri märksõnade hulgas on ka sõna Dokumentaal või dokumentaal, klassifitseerime selle dokumentaalfilmiks; kui anri märksõnade hulgas on sõna Mängufilm või mängufilm, klassifitseerime selle mängufilmiks. ggplot(data = maakonnad) + geom_sf() + geom_sf(data = efis_koord %&gt;% filter(aasta == 2021, grepl(&quot;([dD]okumentaal)|([mM]ängufilm)&quot;, anr)) %&gt;% group_by(koht, anr) %&gt;% summarise(kokku = n()) %&gt;% mutate(anr_bin = ifelse( # tee uus tulp &quot;anr_bin&quot;. Kui... grepl(&quot;[Dd]okumentaal&quot;, anr), # anri tulbas on &quot;Dokumentaal&quot; või &quot;dokumentaal&quot;, &quot;dokumentaal&quot;, # siis määra kategooriaks &quot;dokumentaal&quot;, &quot;mängufilm&quot;) # vastasel juhul &quot;mängufilm&quot; ), aes(size = kokku, color = anr_bin), alpha = 0.2) + scale_size_continuous(range = c(3,7)) + theme_bw() + facet_wrap(&quot;anr_bin&quot;) # jaga andmed anri järgi eri paneelidele Vaatame staatiliste kaartide puhul ka seda, milline on punktitihedus. ggplot(data = maakonnad) + geom_sf() + stat_density_2d(data = efis_koord, # alamandmestiku tihedusfunktsiooni aes(x = st_coordinates(efis_koord)[,1], # x-telje koordinaadid y = st_coordinates(efis_koord)[,2], # y-telje koordinaadid fill = ..level..), # rõngad on värvitud vastavalt tihedusjaotusele geom = &quot;polygon&quot;, # funktsiooni kuvamise tüüp on polügoon alpha = 0.5, # läbipaistvus bins = 30) + # sagedusjoonte arv scale_fill_gradient(low = &quot;lightblue&quot;, high = &quot;darkblue&quot;) + theme_bw() + labs(x = &quot;&quot;, y = &quot;&quot;, fill = &quot;&quot;) Salvestame faili efis_koord faili. st_write(efis_koord, &quot;efis_koord.gpkg&quot;, crs = 3301) 21.2 Shiny rakendus R-is saab interaktiivsete rakenduste tegemiseks kasutada Shiny paketti. Kui sinu RStudios ei ole veel Shiny võimalust, tuleb pakett esmalt installida. # Trüki konsooli if(!&quot;shiny&quot; %in% rownames(installed.packages())) install.packages(&quot;shiny&quot;) # Käsus kontrollitakse, kas shiny pakett sisaldub # installitud pakettide nimede hulgas # ning kui ei sisaldu (hüüumärki kasutatakse mingi tingimuse eitamiseks), # siis installitakse. Seejärel vali File -&gt; New File -&gt; Shiny Web App, anna oma rakendusele nimi (nt efis_shiny vmt) ning jäta rakenduse tüübi (Application type) valikuks Single File. See tähendab, et nii kasutajaliides (ui - see osa, mida kasutaja näeb ja mille abil rakendusega suhtleb) kui ka serveri loogika (server - see osa, mis vastavalt kasutaja valikutele tegelikult andmetega midagi teeb) on ühes R-i failis koos ning selle faili nimi on app.R. Multiple File tähendaks, et ühes failis on kasutajaliidese osa ning teises serveri osa ning kui tahta rakendust kasutada, peavad olemas olema mõlemad failid. Kasutuses kahel variandil praktiliselt vahet ei ole. Vali ka kaust, milles tahad oma rakendust hoida. Selle kausta sisse tekib omakorda kaust sinu rakenduse nimega (nt efis_shiny), mille sees on fail app.R ja mille sisse võiksid minna ka kõik rakenduses kasutatavad failid (nt tabelandmestikud, ruumiandete failid, pildid jm). Avaneb fail app.R, kus on juba valmis põhi, mille sisse saad oma rakendust kirjutada. Vaikimisi põhi on tehtud histogrammi joonistamiseks. Vajuta rohelise noolekesega nupul Run App. Võid valida ka Run in Viewer Pane, et kuvada rakendust RStudio enda keskkonnas. Kui tahad nüüd näha rakenduse endaga paralleelselt koodi, millega rakendus on tehtud, trüki konsooli runExample(\"01_hello\", display.mode = \"showcase\"). Rakenduse minimaalne nõutud struktuur koosneb neljast osast ning näeb välja selline (trellidega on tähistatud kommentaarid): # 1. Rakenduse töötamiseks vajaliku shiny paketi laadimine. # Siin saab sisse lugeda ka teised paketid, # vajalikud andmed ning neid andmeid vajadusel töödelda. library(shiny) # 2. Vahepeal võib veel ka andmeid töödelda. # 3. Kasutajaliides ui &lt;- fluidPage( # Siin saab defineerida, kuidas kasutajaliides välja näeb, sh # kus ja kuidas lasta kasutajal teha mingeid valikuid, # milliseid valikuid kasutaja teha saab # (nt filtreerida algandmetest mingeid andmeid, # muuta mingitel väljundi elementidel värvi, # kujundeid, teksti suurust, väljundit salvestada jne), # milline on kasutaja valikute põhjal genereeritud väljund # (nt kaart, tabel, joonis, tekst jne) # ja kus see paikneb. # fluidPage() teeb lehe, mis kohandub kasutaja brauseriakna suurusega, # fixedPage() teeb lehe, mis on vaikimisi 940 piksli laiune. ) # 4. Serveri loogika server &lt;- function(input, output){ # Siin saab defineerida, mida rakendus kasutaja valikute põhjal teeb # ning kuidas soovitud väljundini jõuda, # nt kui kasutaja valib A, siis tehakse väljund niisugustest andmetest, # kui kasutaja valib B, siis tehakse väljund naasugustest andmetest jne. } # 5. Rakenduse kokkupanemine shinyApp(ui = ui, server = server) Vaatame nüüd rakenduse struktuuri lähemalt ning teeme ise ühe lihtsa rakenduse, mis võtaks sisendiks failid maakond_lihtsustatud.gpkg (polügoonid) ja efis_koord.gpkg (punktid), laseks kasutajal valida, mis aastatest ja mis anrist filmide kohti näidata ning kas näidata neid punktikaardil või tiheduskaardil. Lisaks näitab rakendus ka kasutaja tehtud valikuid ning valitud alamandmestikku tabeli kujul. Võid kasutada vaikimisi avatud rakenduse malli, ent kustuta sel juhul ära kommentaarid ning ui- ja server-funktsioonide sisu. library(shiny) ui &lt;- fluidPage() server &lt;- function(input, output){} shinyApp(ui = ui, server = server) Aseta rakenduse kausta (kus on ka fail app.R) ka vajalikud failid (maakond_lihtsustatud.gpkg ja efis_koord.gpkg). 21.3 Pakettide laadimine ja andmete töötlemine Kõigepealt võiks faili päisesse lisada kommentaarid (kõik #-märkidega read on kommentaarid) selle kohta, mida rakendus teeb, milliseid faile ja pakette kasutab ning kes ja millal on rakenduse teinud. Kommentaarid rakenduses kuskil näha ei jää ega ole rakenduse töötamise seisukohast olulised. # See rakendus kuvab veebikaardi Eesti filmidega seotud kohtadest erinevatel aastatel. # # Rakenduse sisendfailideks on # maakond_lihtsustatud.gpkg ja efis_koord.gpkg. # # Rakendus kasutab pakette shiny, sf ja tidyverse (sh ggplot2). # # Maarja-Liisa Pilvik # 6.12.2021 Järgmiseks laadime rakenduse töötamiseks vajalikud paketid. Kuna vaikimisi avaneval rakendusel pole aimugi, mida rakendusega päriselt tegema hakatakse, on tema ainukeseks nõudeks see, et shiny pakett oleks installitud ja laaditud. Meie laadime lisaks shiny-paketile ka paketid sf ja tidyverse. #-------------------------------------------------# #---1. Laadime paketid ja loeme sisse andmed---#### #-------------------------------------------------# # Paketid library(shiny) # vajalik rakenduse töötamiseks library(sf) # vajalik ruumiandmete sisselugemiseks ja analüüsiks library(tidyverse) # sisaldab paketti ggplot2 (visualiseerimiseks) ning # dplyr ja tidyr (andmetöötluseks) Loeme sisse ka rakenduses kasutatavad andmed ning töötleme neid selleks, et saada sobivam failistruktuur. # Andmed maakonnad &lt;- st_read(&quot;maakond_lihtsustatud.gpkg&quot;) efis &lt;- st_read(&quot;efis_koord.gpkg&quot;) #-------------------------------# #---2. Eeltöötleme andmeid---#### #-------------------------------# # Eraldame kõik võimalikud kategooriad, mille järgi otsida efis$anr %&gt;% strsplit(&quot;,&quot;) %&gt;% # lõikame kategooriad koma koha pealt tükkideks unlist() %&gt;% # teeme saadud listist vektori trimws() %&gt;% # kustutame kategooriate eest ja tagant ära üleliigsed tühikud unique() %&gt;% # jätame iga kategooria kohta alles ainult ühe unikaalse kirje tolower() %&gt;% # teeme kõik kategooriad väiketähelisteks sort() %&gt;% # järjestame kategooriad tähestiku järjekorras kasvavalt .[-1] -&gt; kategooriad # eemaldame esimese kategooria ja salvestame loetelu objekti &quot;kategooriad&quot; # Ühendame dokumentaalfilmid, mängufilmid, kroonikad kategooriad[grepl(&quot;dokumentaal&quot;, kategooriad)] &lt;- &quot;dokumentaal&quot; kategooriad[grepl(&quot;mängufilm&quot;, kategooriad)] &lt;- &quot;mängufilm&quot; kategooriad[grepl(&quot;kroonika&quot;, kategooriad)] &lt;- &quot;kroonika&quot; kategooriad %&gt;% unique() -&gt; kategooriad # jätame alles jälle anult unikaalsed kirjed # Teeme filmide andmestikus ka anrid väiketäheliseks efis$anr %&gt;% tolower() -&gt; efis$anr # Võtame aastast ainult 4 esimest numbrit ja teeme selle arvuliseks tunnuseks efis$aasta %&gt;% substr(., 1, 4) %&gt;% as.numeric() -&gt; efis$aasta 21.4 Kasutajaliides Edasi tuleb kasutajaliidese (ui) osa, mis määrab ära selle, kuidas kasutaja rakendust näeb. Kasutajaliides moodustub hierarhilistest funktsioonidest (funktsioonid tähistatud sulgudega, mille sees täpsustatakse funktsioonide argumente). Meie teeme lihtsa kasutajaliidese, kus on rakenduse pealkiri; menüü, kus saab valida rippmenüüs anri, mille filmide kohti kaardil kuvada; liuguril aastate vahemiku, millest filmide kohti kaardil kuvada; valikunuppudega selle, kas kuvada punktikaarti või tihedusjaotuse kaarti; väljundi ala, kus kuvatakse kasutaja valikuid; väljundi ala, kus näidatakse kasutaja valikutest sõltuvalt kaarti; väljundi ala, kus näidatakse kasutaja valikutest sõltuvalt andmetabelit. #---------------------------------------------# #---3. Ehitame rakenduse kasutajaliidese---#### #---------------------------------------------# ui &lt;- fluidPage( # teeme brauseri akna suurusega sobituva lehekülje, kus on... titlePanel(&quot;Eesti filmide kohad&quot;), # rakenduse pealkiri fluidRow( # rida, kus on kõik kasutaja sisendid: column(4, # kolmandikul kogu akna laiusest selectInput( # valiku rippmenüü inputId = &quot;genre&quot;, # millele viitame edaspidi nimega &quot;genre&quot; label = &quot;Vali anr:&quot;, # mille juures on juhis &quot;Vali anr:&quot; choices = c(&quot;&quot;, kategooriad), # rippmenüüs on tühi valik + kategooriate loend selected = &quot;&quot;, # vaikimisi on valitud tühi valik multiple = FALSE) # mitut kategooriat korraga ei saa valida ), column(4, # teisel kolmandikul kogu akna laiusest on sliderInput( # liugur inputId = &quot;year&quot;, # millele viitame edaspidi nimega &quot;year&quot; label = &quot;Vali aasta(d):&quot;, # mille juures on juhis &quot;Vali aasta(d):&quot; min = min(efis$aasta), # mille vähim valitav väärtus on varaseim aasta max = max(efis$aasta), # mille suurim valitav väärtus on hiliseim aasta value = c(min(efis$aasta), # vaikimisi on valitud kogu liuguri ulatus max(efis$aasta)), # (siin 1921-2021) sep = &quot;&quot;) # ära näita aastaarvudes tuhandete eraldajaid (nt 1,921) ), column(4, # viimasel kolmandikul kogu akna laiusest on radioButtons( # valikunupud inputId = &quot;type&quot;, # millele viitame edaspidi nimega &quot;type&quot; label = &quot;Vali kaarditüüp:&quot;, # mille juures on juhis &quot;Vali kaarditüüp:&quot; choices = c(&quot;punktid&quot;, &quot;tihedusjaotus&quot;), # võimalikud valikud selected = &quot;punktid&quot;) # vaikimisi on valitud punktikaart ) ), hr(), # horisontaalne eraldusjoon, mille all on... verbatimTextOutput(&quot;valik&quot;), # väljund, mis näitab kasutaja tehtud valikuid tekstina tabsetPanel( # vahekaartide paneel tabPanel( # esimesel vahekaardil on title = &quot;Kaart&quot;, # pealkiri &quot;Kaart&quot; plotOutput( # ja graafik, mis näitab kohtade jaotumist Eesti kaardil outputId = &quot;map&quot; # viitame sellele edaspidi nimega &quot;map&quot; ) ), tabPanel( # teisel vahekaardil on title = &quot;Tabel&quot;, # pealkiri &quot;Tabel&quot; dataTableOutput( # ja tabel, mis näitab küsitud tabeli alamosa outputId = &quot;tab&quot; # viitame sellele edaspidi nimega &quot;tab&quot; ) ) ) ) 21.5 Server Järgmiseks defineerime selle, mis juhtub, kui kasutaja mingeid valikuid teeb. Kasutajaliidese Input-klassi elementidele viidatakse serveriosas dollarimärgi ja omistatud id-ga kujul input$... (nt input$genre või input$year). Output-klassi elementidele viidatakse kujul output$... (nt output$map). #----------------------------------# #---4. Ehitame rakenduse sisu---#### #----------------------------------# server &lt;- function(input, output){ # Kõigepealt teeme funktsiooni, mis reageerib kasutaja sisendi valikutele # ja filtreerib andmebaasist soovitud read andmed &lt;- reactive({ if(input$genre != &quot;&quot;){ # kui anri valik ei ole tühi efis %&gt;% # võta efise andmebaas filter( # ja filtreeri sealt välja read, kus grepl(input$genre, anr), # anri tulp sisaldaks (mh) küsitud anri aasta &gt;= input$year[1], # aasta tulbas oleks liuguri alumisest otsast suurem/võrdne väärtus aasta &lt;= input$year[2]) # aasta tulbas oleks liuguri ülemisest otsast väiksem/võrdne väärtus } }) # Täidame kõigepealt kasutaja valikute väljundiosa output$valik &lt;- renderText({ # Näita väljundiosas teksti, kus... paste0(&quot;Valitud &quot;, # on kokku kleebitud sõna &quot;Valitud&quot; input$genre, # valitud anri nimi &quot; (&quot;, # tühik ja algav sulg input$year[1], # valitud kõige varasem aasta &quot;-&quot;, # sidekriips input$year[2], # valitud kõige pikem aasta &quot;)&quot;) # ja lõpetav sulg }) # Täidame kaardi vahelehe output$map &lt;- renderPlot({ # Joonistame vahelehele joonise, kus... if(input$genre != &quot;&quot;){ # juhul, kui anri valik ei ole tühi dat &lt;- andmed() # jooksutame funktsiooni &quot;andmed()&quot; ja salvestame tulemuse objekti &quot;dat&quot; if(input$type == &quot;punktid&quot;){ # kui kasutaja tahab näha punktikaarti # joonistame punktikaardi ggplot(data = maakonnad) + geom_sf() + # maakondade aluskaardi kiht, millele lisame geom_sf(data = dat %&gt;% # valitud andmete alamosa kihi, kus on... group_by(koht) %&gt;% # iga koha punktid (konkreetsel perioodil ja konkreetses anris) summarise(kokku = n()), # kokku loetud aes(size = kokku), # punktide suuruse näitab konkreetse koha esinemise arvu alpha = 0.2, # punktid on tehtud üsna läbipaistvaks color = &quot;red&quot;) + # ja värvitud punaseks theme_bw() # kasutame mustvalget teemat } else{ # kui kasutaja ei taha näha punktikaarti (= tahab näha tihedusjaotuse kaarti) if(nrow(dat) &gt; 10){ # kui alamandmestikus on vähemalt 10 rida # joonistame tihedusjaotuse kaardi ggplot(data = maakonnad) + geom_sf() + # maakondade aluskaardi kiht, millele lisame stat_density_2d(data = dat, # alamandmestiku tihedusfunktsiooni aes(x = st_coordinates(dat)[,1], # x-telje koordinaadid y = st_coordinates(dat)[,2], # y-telje koordinaadid fill = ..level..), # rõngad on värvitud vastavalt tihedusjaotusele geom = &quot;polygon&quot;, # funktsiooni kuvamise tüüp on polügoon alpha = 0.5) + # kiht on üsna läbipaistev scale_fill_gradient(low = &quot;lightblue&quot;, high = &quot;darkblue&quot;) + # määrame värviskaala theme_bw() # kasutame mustvalget teemat } else{ # kui alamandmestikust on 10 või vähem rida showModal( modalDialog(&quot;Liiga vähe andmepunkte!&quot;, size = &quot;s&quot;) # näitame ainult vastavat teadet ) } } } }) # Täidame alamandmestiku vahelehe output$tab &lt;- renderDataTable({ # Teeme andmetabeli, kus... if(input$genre != &quot;&quot;){ # juhul, kui anri valik ei ole tühi andmed() %&gt;% # näitame kasutaja valitud alamandmestikku st_set_geometry(NULL) # ilma ruumiinfota } }) } 21.6 Rakenduse kokkupanemine Kõige lõpuks on vaja rakendus kasutajaliidesest ja serverist kokku panna. #------------------------------------------------# #---5. Paneme kasutajaliidese ja sisu kokku---#### #------------------------------------------------# shinyApp(ui = ui, server = server) Jooksutame rakendust ning vaatame, mis saab. Meie rakendus teeb oma töö ära, ent on nii kujunduselt kui ka kasutusmugavuse mõttes üsna algeline. Shinys saab aga muuta ja lisada veel lugematul hulgal asju, parandada rakenduse kiirust jne. Hea samm-sammulise sissejuhatuse rakenduste tegemisse leiab siit. 21.7 Rakenduse jagamine Shiny rakendusi saab jagada ainult kas lokaalselt (app.R + selle juurde kuuluvad failid) või üles laadituna serverisse, kuhu on installitud ka R ja Shiny Server (viimast saab installida ainult Linuxis). See tähendab, et tavalist HTML-faili Shiny rakendusest otse teha ei saa, sest JavaScript ei tea, mida R-i kooditükkidega pihta hakata. Küll aga saab rakenduse üles laadida näiteks shinyapps.io serverisse ning lisada rakenduse seejärel iframei abil mõne teise (HTMLis) veebilehe sisse. Shinyapps.io pakub Shiny rakenduste majutuse teenust, kusjuures tasuta saab üles laadida kuni 5 rakendust ja neid ei saa serveris ühes kuus aktiivselt kasutada rohkem kui 25 tundi. Rakenduse laadimiseks serverisse tuleb esmalt teha endale shinyapps.io kasutaja, logida sisse ning valida seejärel Account -&gt; Tokens. Samal ajal installi endale R-is pakett rsconnect ja laadi see. install.packages(&quot;rsconnect&quot;) library(rsconnect) Nüüd vali shinyapps.io lehel Tokens alamlehel Show -&gt; Copy to clipboard, kopeeri esitatud kood ning tee RStudio konsoolis paremklikk -&gt; Paste või vajuta Ctrl+V. Nii ühendad lokaalselt installitud R-i ja enda kasutaja shinyapps.io serveris. Rakenduse üleslaadimiseks trüki konsooli deployApp() ning anna argumendiks selle kausta teekond, kus rakendus on (juhul, kui rakendus on kaustas, mida näitab funktsioon getwd(), piisab lihtsalt kausta nimest). deployApp(&quot;efis_shiny&quot;) Selle tulemusel avaneb lõpuks lehekülg https://sinukasutajanimi.shinyapps.io/rakendusenimi/. Vaata täpsemalt siit. Üles laaditud rakenduse saab panna iframe-i abil HTML-faili. Vaata rohkem näiteid siit. R-i ja ruumiandmete kohta on hea ja ülevaatlik kursus ka aadressil http://aasa.ut.ee/Rspatial/. "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
